---
title: "Analysis of FMT Model for Humanized Mice"
editor_options:
  markdown:
    wrap: 72
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

## Introduction

In our examination of a more stable and reproducible fecal microbiome
transfer (FMT) model between human and mice, we used 16S rRNA amplicon
sequence data of stool samples from both humans and mice throughout
various iterations of fecal transfers. The different iterations of fecal
transfers include generational, serial transfers (human to mouse,
human-adapted mouse to mouse) and in two different host environments
(inflamed and non-inflamed).

This notebook includes R scripts that generated PCoA plots, boxplots,
and scatterplots presented in the published manuscript.

Taxonomic barplots and alpha diversity plots were generated through the
Plotmicrobiome application.

A core set of figures from the manuscript were independently replicated
by Jacqueline B. Young using Python. Both the Python scripts and
replicated figures are provided in a Jupyter Notebook file (PDF format).

The Github link to the Plotmicrobiome application and the Python
validation files are provided at the end of our manuscript.

Please refer to the ReadMe file on our Github respository for additional
notes on running the scripts in this R notebook.

## Analysis Overview

Each code chunk follows a step of the analysis pipeline:

-   Installing all relevant libraries
-   Data import and parsing
-   PCoA Plots
-   Transfer efficiency calculations of samples within a given FMT group
-   Transfer efficiency calculations of samples across a pair of FMT
    groups
-   Visualizing the non-transferred ASV abundance in samples across a
    pair of FMT groups
-   Testing homogeneity of variances among histology tissue scores
-   Assessing cage effect on transfer efficiency of samples within
    groups
-   Assessing protein assay data (fLCN2)
-   Control Experiment: Human to Mice in a gnotobiotic isolator

#### Installing libraries

The code below insalls and loads all dependencies used throughout this
analysis.

```{r, message=FALSE, results='hide', fig.show='hide'}

packagesToInstall = c("ggplot2", "vegan", "dplyr", "testthat", "stats","car","here")
install.packages(packagesToInstall,repos = "http://cran.us.r-project.org") 
lapply(packagesToInstall, library, character.only=TRUE)

```

#### Data import and parsing

Next, the script below reads in all the functions that are used
throughout this analysis.

We recommend organizing these functions, which exist as external,
independent R scripts, in the same directory as the R Notebook file.

```{r, message=FALSE, results='hide', fig.show='hide'}
allScripts = c("lognorm_function.R","generatePCOAPlots.R",
               "getCorrelationCoefficient_acrossGroup.R",
               "getCorrelationCoefficient_withinGroup.R",
               "getCorrelationCoefficient_withinGroup_phylumLevel_byGroup.R", 
               "getCorrelationCoefficient_withinGroup_perCage.R",
               "generateTableWithTaxonomy_NontransferringASVS_samplePairsAcrossGroup.R",
               "generateScatterPlots_samplePairsAcrossGroup_histogramOfNontransferringASVS.R",
               "calculateBartlettPvalue_histologyScoreData.R","calculateLevenesTestPvalue_histologyScoreData.R",
               "generateScatterplots_acrossGroup.R"
               )

for(i in 1:length(allScripts)){
  source(allScripts[i], local = knitr::knit_global())
}

```

The code below reads in the counts data and metadata files, starting
with the counts data at the ASV level, with a total sample size 110
sequenced samples. This includes three technical replicates of pooled
human donor slurries and for each input mice slurry group.

QIIME2 generates counts table in a feature x sample format, in which
features (taxa) are in rows and samples are columns. In our first step
of reading in these counts data files into our R scripts, we maintained
the format integrity (features as rows and samples as columns). Later,
we transpose the counts table to match the format of the metadata file,
which has samples as rows and features as columns.

Note: Early in our analysis, we updated the nomenclature system of our
FMT groups to improve readability. Hence, we provide the metadata with
the original and the updated nomenclature, the latter which we use for
our published results and manuscript. In addition to updating
nomenclature, which we updated in Excel, we formatted the sample names
to make it R-friendly (i.e. change "-" into "." in sample names because
R interprets "-" between integers as a mathematics operation). If
original counts tables are read into Python, these changes are not
needed. The Python validation scripts uses the metadata and counts files
with the original nomenclature.

```{r, message=FALSE, results='hide', fig.show='hide'}

file_asv_updatedName = read.table(here("files","countsTable_asv_importToR_updatedNomenclature.txt"), header = T, sep = "\t")
metamapping_updatedName = read.table(here("files","mappingMetadata_updatedNomenclature.txt"), header = T, sep = "\t")
asv_taxonomy_map= read.table(here("files","asv_taxonomy_map.txt"), sep = "\t", header = TRUE)
                             
## group labels
labels_inputRecipientGroups = unique(metamapping_updatedName$FMTGroupFMTsource..Recipientbackground)

file_asv_updatedName_t = t(file_asv_updatedName)
file_asv_updatedName_t_samplesOnly = file_asv_updatedName_t[-(c(1,nrow(file_asv_updatedName_t))),]
colnames(file_asv_updatedName_t_samplesOnly) = file_asv_updatedName_t[1,]


file_asv_updatedName_t_samplesOnly_toMerge = as.data.frame(file_asv_updatedName_t_samplesOnly)
file_asv_updatedName_t_samplesOnly_toMerge$SampleID = rownames(file_asv_updatedName_t_samplesOnly)

#merge counts and metadata files
myASVandMetadata_newNames = full_join(file_asv_updatedName_t_samplesOnly_toMerge, metamapping_updatedName, by="SampleID")

names(myASVandMetadata_newNames)[names(myASVandMetadata_newNames)=="FMTGroupFMTsource..Recipientbackground"] = "FMTGroupFMTsourcegtRecipientbackground"

##lognorm
file_asv_updatedName_t_samplesOnly_df = as.data.frame(file_asv_updatedName_t_samplesOnly)
file_asv_updatedName_t_samplesOnly_df[] <- lapply(file_asv_updatedName_t_samplesOnly_df, function(x) as.numeric(as.character(x)))

file_asv_updatedName_t_samplesOnly_lognorm = lognorm_function(file_asv_updatedName_t_samplesOnly_df)

# serial passage groups
labels_NIMM_lineage = c("HM1input", "HM1->WT", "NIMM-g1input", "NIMM-g1->WT", "NIMM-g2input", "NIMM-g2->WT")
labels_IMM_lineage = c("HM1input", "HM1->KO", "IMM-g1input", "IMM-g1->KO","IMM-g2input", "IMM-g2->KO")

```

The code below parses and log normalizes the genus counts table:

```{r, message=FALSE, results='hide', fig.show='hide'}

file_genusCountsTable_updatedName = read.table(here("files","countsTable_genus_importToR_updatedNomenclature.txt"), header = T, sep = "\t")
metamapping_updatedName = read.table(here("files","mappingMetadata_updatedNomenclature.txt"), header = T, sep = "\t")

file_genusCountsTable_updatedName_t = t(file_genusCountsTable_updatedName)

genusCountsTable_samplebyfeatureFormat = file_genusCountsTable_updatedName_t[-1,]
colnames(genusCountsTable_samplebyfeatureFormat) = file_genusCountsTable_updatedName_t[1,]

genusCounts_samplesOnly_toMerge = as.data.frame(genusCountsTable_samplebyfeatureFormat)
genusCounts_samplesOnly_toMerge$SampleID = rownames(genusCountsTable_samplebyfeatureFormat)

#merge counts and metadata files
genusCountsandMetadata = full_join(genusCounts_samplesOnly_toMerge, metamapping_updatedName, by="SampleID")

names(genusCountsandMetadata)[names(genusCountsandMetadata)=="FMTGroupFMTsource..Recipientbackground"] = "FMTGroupFMTsourcegtRecipientbackground"

##lognorm
genusCounts_samplesOnly_df = as.data.frame(genusCountsTable_samplebyfeatureFormat)
genusCounts_samplesOnly_df[] <- lapply(genusCounts_samplesOnly_df, function(x) as.numeric(as.character(x)))

genusCounts_samplesOnly_df_lognorm = lognorm_function(genusCounts_samplesOnly_df)

```

Below, the code parses and log normalizes the phylum counts table:

```{r, message=FALSE, results='hide', fig.show='hide'}

file_phylumCountsTable_updatedName = read.table(here("files","countsTable_phylum_importToR_updatedNomenclature.txt"), header = T, sep = "\t")
metamapping_updatedName = read.table(here("files","mappingMetadata_updatedNomenclature.txt"), header = T, sep = "\t")

file_phylumCountsTable_updatedName_t = t(file_phylumCountsTable_updatedName)

phylumCountsTable_samplebyfeatureFormat = file_phylumCountsTable_updatedName_t[-1,]
colnames(phylumCountsTable_samplebyfeatureFormat) = file_phylumCountsTable_updatedName_t[1,]

phylumCounts_samplesOnly_toMerge = as.data.frame(phylumCountsTable_samplebyfeatureFormat)
phylumCounts_samplesOnly_toMerge$SampleID = rownames(phylumCountsTable_samplebyfeatureFormat)

#merge counts and metadata files
phylumCountsandMetadata = full_join(phylumCounts_samplesOnly_toMerge, metamapping_updatedName, by="SampleID")

names(phylumCountsandMetadata)[names(phylumCountsandMetadata)=="FMTGroupFMTsource..Recipientbackground"] = "FMTGroupFMTsourcegtRecipientbackground"

##lognorm
phylumCounts_samplesOnly_df = as.data.frame(phylumCountsTable_samplebyfeatureFormat)
phylumCounts_samplesOnly_df[] <- lapply(phylumCounts_samplesOnly_df, function(x) as.numeric(as.character(x)))

phylumCounts_samplesOnly_df_lognorm = lognorm_function(phylumCounts_samplesOnly_df)

```

#### PCoA Plots

PCoA plots were generated with the capscale function from the vegan
package using Bray-Curtis dissimilarity matrix.

```{r, message=FALSE, results='hide', fig.show='hide'}
dir.create(here("PcoaPlots"))

plotColors_ver2 = c("gray65", "royalblue1", "green", "orange", "purple",  
                    "black", "olivedrab", "red", "red4", 
                      "cyan","palevioletred1", "blue3", "yellow2", "magenta")  
                    
               
metagroup = factor(myASVandMetadata_newNames$FMTGroupFMTsourcegtRecipientbackground)

micegroups_all = c("HM1->KO", "HM1->WT", "IMM-g1->KO", "IMM-g2->KO", "NIMM-g1->WT","NIMM-g2->WT") 
micegroups_inflamed = c("HM1->KO", "IMM-g1->KO","IMM-g2->KO", "IMM-g1input", "IMM-g2input") 
micegroups_noninflamed = c("HM1->WT", "NIMM-g1->WT","NIMM-g2->WT", "NIMM-g1input", "NIMM-g2input") 
excludecrossoverGroup = unique(genusCountsandMetadata$FMTGroupFMTsourcegtRecipientbackground)
excludecrossoverGroup = excludecrossoverGroup[-11]
micegroups_inflamed_withbothHMCohorts = c("HM1->KO", "HM2->KO","IMM-g1->KO","IMM-g2->KO", "IMM-g1input", "IMM-g2input") 
micegroups_serialTransfersPlusCrossover = c("HM1->KO", "HM1->WT", "IMM-g1->KO", "IMM-g2->KO", "NIMM-g1->WT","NIMM-g2->WT", "NIMM-g1->KO")

micegroups_all.samplesindex = genusCountsandMetadata$SampleID[genusCountsandMetadata$FMTGroupFMTsourcegtRecipientbackground %in% micegroups_all]
micegroups_inflamed.samplesindex = genusCountsandMetadata$SampleID[genusCountsandMetadata$FMTGroupFMTsourcegtRecipientbackground %in% micegroups_inflamed]
micegroups_noninflamed.samplesindex = genusCountsandMetadata$SampleID[genusCountsandMetadata$FMTGroupFMTsourcegtRecipientbackground %in% micegroups_noninflamed]
excludcrossoverGroup.samplesindex = genusCountsandMetadata$SampleID[genusCountsandMetadata$FMTGroupFMTsourcegtRecipientbackground %in% excludecrossoverGroup]
micegroups_inflamed_withbothHMCohorts.samplesindex = genusCountsandMetadata$SampleID[genusCountsandMetadata$FMTGroupFMTsourcegtRecipientbackground %in% micegroups_inflamed_withbothHMCohorts]
micegroups_serialTransfersPlusCrossover.samplesindex = genusCountsandMetadata$SampleID[genusCountsandMetadata$FMTGroupFMTsourcegtRecipientbackground %in% micegroups_serialTransfersPlusCrossover]

micegroups_all.metagroup = factor(metagroup[metagroup %in% micegroups_all])
micegroups_inflamed.metagroup = factor(metagroup[metagroup %in% micegroups_inflamed])
micegroups_noninflamed.metagroup = factor(metagroup[metagroup %in% micegroups_noninflamed])
excludecrossoverGroup.metagroup = factor(metagroup[metagroup %in% excludecrossoverGroup])
micegroups_inflamed_withbothHMCohorts.metagroup = factor(metagroup[metagroup %in% micegroups_inflamed_withbothHMCohorts])
micegroups_serialTransfersPlusCrossover.metagroup = factor(metagroup[metagroup %in% micegroups_serialTransfersPlusCrossover])

  ## all mice groups
micegroups_all_genusCounts_samplesOnly_lognorm_df = genusCounts_samplesOnly_df_lognorm[rownames(genusCounts_samplesOnly_df_lognorm) %in% micegroups_all.samplesindex,]
micegroups_all.metagroup
micegroups_all_colors = plotColors_ver2[levels(metagroup) %in% micegroups_all]
  ## KO mice groups
micegroups_inflamed_genusCounts_samplesOnly_lognorm_df = genusCounts_samplesOnly_df_lognorm[rownames(genusCounts_samplesOnly_df_lognorm) %in% micegroups_inflamed.samplesindex,]
micegroups_inflamed.metagroup
micegroups_inflamed_colors = plotColors_ver2[levels(metagroup) %in% micegroups_inflamed]
  ## WT mice groups
micegroups_noninflamed_genusCounts_samplesOnly_lognorm_df = genusCounts_samplesOnly_df_lognorm[rownames(genusCounts_samplesOnly_df_lognorm) %in% micegroups_noninflamed.samplesindex,]
micegroups_noninflamed.metagroup
micegroups_noninflamed_colors = plotColors_ver2[levels(metagroup) %in% micegroups_noninflamed]
  ## excluding crossover group
excludecrossoverGroup_genusCounts_samplesOnly_lognorm_df = genusCounts_samplesOnly_df_lognorm[rownames(genusCounts_samplesOnly_df_lognorm) %in% excludcrossoverGroup.samplesindex,]
excludecrossoverGroup.metagroup
excludecrossoverGroup_colors = plotColors_ver2[levels(metagroup) %in% excludecrossoverGroup]
  ## KO mice groups with both HM cohorts
micegroups_inflamed_withbothHMCohorts_genusCounts_samplesOnly_lognorm_df = genusCounts_samplesOnly_df_lognorm[rownames(genusCounts_samplesOnly_df_lognorm) %in% micegroups_inflamed_withbothHMCohorts.samplesindex,]
micegroups_inflamed_withbothHMCohorts.metagroup
micegroups_inflamed_withbothHMCohorts_colors = plotColors_ver2[levels(metagroup) %in% micegroups_inflamed_withbothHMCohorts]

## serial transfer groups plus crossover group
micegroups_serialTransfersPlusCrossover_genusCounts_samplesOnly_lognorm_df = genusCounts_samplesOnly_df_lognorm[rownames(genusCounts_samplesOnly_df_lognorm) %in% micegroups_serialTransfersPlusCrossover.samplesindex,]
micegroups_serialTransfersPlusCrossover.metagroup
micegroups_serialTransfersPlusCrossover_colors = plotColors_ver2[levels(metagroup) %in% micegroups_serialTransfersPlusCrossover]


pdf(here("PcoaPlots","PCoAPlots.pdf"))
generatePCOAPlots(micegroups_serialTransfersPlusCrossover_genusCounts_samplesOnly_lognorm_df, 
                  micegroups_serialTransfersPlusCrossover.metagroup,
                  micegroups_serialTransfersPlusCrossover_colors, legendlocation = "topright", 
                  plotTitle="Mice Groups, Including Crossover Group")

generatePCOAPlots(micegroups_inflamed_withbothHMCohorts_genusCounts_samplesOnly_lognorm_df, 
                  micegroups_inflamed_withbothHMCohorts.metagroup,
                  micegroups_inflamed_withbothHMCohorts_colors, legendlocation = "topleft", plotTitle="Inflamed Mice Groups, Both HM Cohorts")

generatePCOAPlots(genusCounts_samplesOnly_df_lognorm, metagroup,
                  plotColors_ver2, legendlocation = "bottomleft", plotTitle="All Groups")

generatePCOAPlots(micegroups_all_genusCounts_samplesOnly_lognorm_df, micegroups_all.metagroup,
                  micegroups_all_colors, legendlocation = "topright", plotTitle="Mice Groups Only")

generatePCOAPlots(excludecrossoverGroup_genusCounts_samplesOnly_lognorm_df, excludecrossoverGroup.metagroup,
                  excludecrossoverGroup_colors, legendlocation = "topleft", plotTitle="Excluding Cross-Over Group")

generatePCOAPlots(micegroups_noninflamed_genusCounts_samplesOnly_lognorm_df, micegroups_noninflamed.metagroup,
                  micegroups_noninflamed_colors, legendlocation = "topright", plotTitle="Non-inflamed Mice Groups")

generatePCOAPlots(micegroups_inflamed_genusCounts_samplesOnly_lognorm_df, micegroups_inflamed.metagroup, micegroups_inflamed_colors, legendlocation = "topright", plotTitle="Inflamed Mice Groups")

dev.off()

```

### Correlations and Scatterplots

The next few segments of code generates the following:

-   Correlation coefficients for sample-pairs 1) within group and
    2)  across groups
-   Boxplots that summarize the correlation coefficients
-   Scatterplots for each sample-pair comparison, which reflects
    relative abundance for each ASV between a given pair of samples

#### ASV Transfer Efficiencies Within FMT Groups

This first code chunk calculates the correlation of samples within the
same group.

```{r, message=FALSE, results='hide', fig.show='hide'}

file_asv_updatedName_t_samplesOnly_lognorm 
labels_inputRecipientGroups 

# serial passage groups
labels_NIMM_lineage = c("HM1input", "HM1->WT", "NIMM-g1input", "NIMM-g1->WT", "NIMM-g2input", "NIMM-g2->WT")
labels_IMM_lineage = c("HM1input", "HM1->KO", "IMM-g1input", "IMM-g1->KO","IMM-g2input", "IMM-g2->KO")
labels_serialpassage_newNames = c("HM1input", "HM1->WT", "NIMM-g1input", "NIMM-g1->WT", "NIMM-g2input", "NIMM-g2->WT","HM1->KO", "IMM-g1input", "IMM-g1->KO","IMM-g2input", "IMM-g2->KO")
myASVandMetadata_newNames
names(myASVandMetadata_newNames)[names(myASVandMetadata_newNames)=="FMTGroupFMTsource..Recipientbackground"] = "FMTGroupFMTsourcegtRecipientbackground"

## scatterplots
dir.create(here("boxplots","acrossGroups_pearson"),recursive = T)
dir.create(here("boxplots","withinGroups_pearson"),recursive = T)
dir.create(here("asvAbundance_scatterplots","acrossGroups_pearson"), recursive = T)

  #within groups
withinGroup_pearson_newNames_serialpassage=getCorrelationCoefficient_withinGroup(groupList=labels_serialpassage_newNames, tableWithMeta=myASVandMetadata_newNames, tableCountsOnly=file_asv_updatedName_t_samplesOnly_lognorm, corrTestMethod="pearson",sampleColumnName = "SampleID", variableName = "FMTGroupFMTsourcegtRecipientbackground")

withinGroup_pearson_newNames_NIMMlineage=getCorrelationCoefficient_withinGroup(groupList=labels_NIMM_lineage, tableWithMeta=myASVandMetadata_newNames, tableCountsOnly=file_asv_updatedName_t_samplesOnly_lognorm, corrTestMethod="pearson",sampleColumnName = "SampleID", variableName = "FMTGroupFMTsourcegtRecipientbackground")

withinGroup_pearson_newNames_IMMlineage=getCorrelationCoefficient_withinGroup(groupList=labels_IMM_lineage, tableWithMeta=myASVandMetadata_newNames, tableCountsOnly=file_asv_updatedName_t_samplesOnly_lognorm, corrTestMethod="pearson",sampleColumnName = "SampleID", variableName = "FMTGroupFMTsourcegtRecipientbackground")


## figure 4s
withinGroup_pearson_IMMlineage_genusCounts =getCorrelationCoefficient_withinGroup(groupList=labels_IMM_lineage, tableWithMeta=myASVandMetadata_newNames, tableCountsOnly=file_asv_updatedName_t_samplesOnly_lognorm, corrTestMethod="pearson",sampleColumnName = "SampleID", variableName = "FMTGroupFMTsourcegtRecipientbackground")


## create pdf of boxplots 
pdf(here("boxplots","withinGroups_pearson","asv_boxplots_withinGroup_allSerialPassage.pdf"), height = 8, width = 10)
boxplot(withinGroup_pearson_newNames_serialpassage,names = labels_serialpassage_newNames, las=2, cex.axis=0.70,
        main="Correlation Coefficients Within Groups, All Serial Passage Groups", cex.main=0.8)
dev.off()

pdf(here("boxplots","withinGroups_pearson","asv_boxplots_withinGroup_SerialPassage_NIMM.pdf"), height = 8, width = 10)
boxplot(withinGroup_pearson_newNames_NIMMlineage,names = labels_NIMM_lineage, las=2, cex.axis=0.70,
        main="Correlation Coefficients Within Groups, Serial Passage for NIMM Lineage", cex.main=0.8)
dev.off()

pdf(here("boxplots","withinGroups_pearson","asv_boxplots_withinGroup_SerialPassage_IMM.pdf"), height = 8, width = 10)
boxplot(withinGroup_pearson_newNames_IMMlineage,names = labels_IMM_lineage, las=2, cex.axis=0.70,
        main="Correlation Coefficients Within Groups, Serial Passage for IMM Lineage", cex.main=0.8)
dev.off()


#scatterplots, asv correlation for samples across groups
generateScatterplots_acrossGroup(groupList=labels_serialpassage_newNames, tableWithMeta=myASVandMetadata_newNames,corrTestMethod = "pearson"  ,
                                 variableName = "FMTGroupFMTsourcegtRecipientbackground", sampleColumnName ="SampleID" ,tableCountsOnly=file_asv_updatedName_t_samplesOnly_lognorm, resultsDirectory = here("asvAbundance_scatterplots","acrossGroups_pearson","scatterplot_"))

```

#### ASV Transfer Efficiencies Within FMT Groups: Human Cohorts

Next, we generate correlations (within groups) for samples within only
human cohorts (HM1, HM2), which are then visually summarized as
boxplots.

```{r, message=FALSE, results='hide', fig.show='hide'}

labels_bothHumanCohorts = c("HM1->KO", "HM2->KO")

withinGroup_pearson_humanCohortsOnly = getCorrelationCoefficient_withinGroup(groupList=labels_bothHumanCohorts, tableWithMeta=myASVandMetadata_newNames, tableCountsOnly=file_asv_updatedName_t_samplesOnly_lognorm, corrTestMethod="pearson", variableName = "FMTGroupFMTsourcegtRecipientbackground", sampleColumnName = "SampleID")

pdf(here("boxplots","withinGroups_pearson", "ASV_boxplot_withinGroup_bothHumanCohortsOnly.pdf"))
boxplot(withinGroup_pearson_humanCohortsOnly,names = labels_bothHumanCohorts, las=2, cex.axis=0.70,
        main="Pearson Correlation Coefficients Within Groups, Human Cohorts 1 and 2", cex.main=0.8)
stripchart(withinGroup_pearson_humanCohortsOnly, add=TRUE, pch=16, col=c("green", "purple"), method="jitter", vertical = T)

dev.off()

myList =c("HM1->WT", "NIMM-g1->WT", "NIMM-g2->WT","HM1->KO", "IMM-g1->KO", "IMM-g2->KO")

withinGroup_pearson_theSixGroups = getCorrelationCoefficient_withinGroup(groupList=myList, tableWithMeta=myASVandMetadata_newNames, tableCountsOnly=file_asv_updatedName_t_samplesOnly_lognorm, corrTestMethod="pearson", variableName = "FMTGroupFMTsourcegtRecipientbackground", sampleColumnName = "SampleID")

pdf(here("boxplots","withinGroups_pearson", "ASV_boxplot_withinGroup_WTandKOgroups.pdf"))

boxplot(withinGroup_pearson_theSixGroups,names = myList, las=2, cex.axis=0.70,
        main="Pearson Correlation Coefficients Within Groups, WT vs KO", cex.main=0.8)
stripchart(withinGroup_pearson_theSixGroups, add=TRUE, pch=16, col="blue", method="jitter", vertical = T)

dev.off()


```

#### ASV Transfer Efficiencies Across FMT Groups

The code below generates ASV scatterplots and boxplots for samples
across groups. This first code chunk sets the FMT groups of interest for
the following analysis.

```{r, message=FALSE, results='hide', fig.show='hide'}

file_asv_updatedName_t_samplesOnly_lognorm 
labels_inputRecipientGroups 

labels_NIMM_lineage = c("HM1input", "HM1->WT", "NIMM-g1input", "NIMM-g1->WT", "NIMM-g2input", "NIMM-g2->WT")
labels_IMM_lineage = c("HM1input", "HM1->KO", "IMM-g1input", "IMM-g1->KO","IMM-g2input", "IMM-g2->KO")
labels_serialpassage_newNames = c("HM1input", "HM1->WT", "NIMM-g1input", "NIMM-g1->WT", "NIMM-g2input", "NIMM-g2->WT","HM1->KO", "IMM-g1input", "IMM-g1->KO","IMM-g2input", "IMM-g2->KO")
myASVandMetadata_newNames

#indexing groups of interest for asv correlation boxplots
fig4a.wtlineage.index = c(1,20,35)
fig4a.wtlineage.supp.index = c(2,4,21)

fig4b.kolineage.index = c(6,50,55)
fig4b.kolineage.supp.index = c(7,9,51)

fig4c.index = c(12,29,47,54)
fig4c.supp.index = c(32,43,34,45)

```

Next, we generate the correlations between samples from across groups at
three taxonomic levels: strain level (ASV), genus, and phylum.

```{r, message=FALSE, results='hide', fig.show='hide'}
#across groups
  ## asv level counts
corr_acrossGroups_pearson_asvCounts_withHuman = getCorrelationCoefficient_acrossGroup(groupList=labels_serialpassage_newNames, tableWithMeta=myASVandMetadata_newNames, tableCountsOnly=file_asv_updatedName_t_samplesOnly_lognorm, corrTestMethod="pearson",variableName = "FMTGroupFMTsourcegtRecipientbackground", sampleColumnName = "SampleID")

  ## genus level counts
corr_acrossGroups_pearson_GenusCounts_withHuman = getCorrelationCoefficient_acrossGroup(groupList=labels_serialpassage_newNames, tableWithMeta=genusCountsandMetadata, tableCountsOnly=genusCounts_samplesOnly_df_lognorm, 
corrTestMethod="pearson", variableName = "FMTGroupFMTsourcegtRecipientbackground", sampleColumnName = "SampleID")


    ## phylum level counts
corr_acrossGroups_pearson_PhylumCounts_withHuman = getCorrelationCoefficient_acrossGroup(groupList=labels_serialpassage_newNames, tableWithMeta=phylumCountsandMetadata, tableCountsOnly=phylumCounts_samplesOnly_df_lognorm, 
corrTestMethod="pearson", variableName = "FMTGroupFMTsourcegtRecipientbackground", sampleColumnName = "SampleID")


```

These boxplots are for inflamed (KO) groups in our SV transfer
comparison across groups.

```{r, message=FALSE, results='hide', fig.show='hide'}
  #asv level counts
pdf(here("boxplots","acrossGroups_pearson", "fig4_inflamed_asv.pdf"))
boxplot(corr_acrossGroups_pearson_asvCounts_withHuman[[2]][fig4b.kolineage.index],names = corr_acrossGroups_pearson_asvCounts_withHuman[[1]][fig4b.kolineage.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Inflamed Groups", cex.main=0.8,
        ylim=c(0,1))
dev.off()

pdf(here("boxplots","acrossGroups_pearson","fig4_inflamed_asv_supp.pdf"))
boxplot(corr_acrossGroups_pearson_asvCounts_withHuman[[2]][fig4b.kolineage.supp.index],names = corr_acrossGroups_pearson_asvCounts_withHuman[[1]][fig4b.kolineage.supp.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Inflamed Groups (SUPPFIG)", cex.main=0.8,
        ylim=c(0,1))
dev.off()

  # genus level counts 

pdf(here("boxplots","acrossGroups_pearson","fig4_inflamed_genus.pdf"))
boxplot(corr_acrossGroups_pearson_GenusCounts_withHuman[[2]][fig4b.kolineage.index],names = corr_acrossGroups_pearson_GenusCounts_withHuman[[1]][fig4b.kolineage.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Inflamed Groups (Genus)", cex.main=0.8,
        ylim=c(0,1))
dev.off()

pdf(here("boxplots","acrossGroups_pearson","fig4_inflamed_genus_supp.pdf"))
boxplot(corr_acrossGroups_pearson_GenusCounts_withHuman[[2]][fig4b.kolineage.supp.index],names = corr_acrossGroups_pearson_GenusCounts_withHuman[[1]][fig4b.kolineage.supp.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Inflamed Groups (Genus) (SUPPFIG)", cex.main=0.8,
        ylim=c(0,1))
dev.off()

    #phylum counts

pdf(here("boxplots","acrossGroups_pearson", "fig4_inflamed_phylum.pdf"))
boxplot(corr_acrossGroups_pearson_PhylumCounts_withHuman[[2]][fig4b.kolineage.index],names = corr_acrossGroups_pearson_PhylumCounts_withHuman[[1]][fig4b.kolineage.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Inflamed Groups (Phylum)", cex.main=0.8,
        ylim=c(0,1))
dev.off()

pdf(here("boxplots","acrossGroups_pearson","fig4_inflamed_phylum_supp.pdf"))
boxplot(corr_acrossGroups_pearson_PhylumCounts_withHuman[[2]][fig4b.kolineage.supp.index],names = corr_acrossGroups_pearson_PhylumCounts_withHuman[[1]][fig4b.kolineage.supp.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Inflamed Groups (Phylum, SUPPFIG)", cex.main=0.8,
        ylim=c(0,1))
dev.off()

```

These boxplots are for non-inflamed (WT) groups in our SV transfer
comparison across groups.

```{r, message=FALSE, results='hide', fig.show='hide'}

#asv counts

pdf(here("boxplots","acrossGroups_pearson","fig4_NONinflamed_asv.pdf"))
boxplot(corr_acrossGroups_pearson_asvCounts_withHuman[[2]][fig4a.wtlineage.index],names = corr_acrossGroups_pearson_asvCounts_withHuman[[1]][fig4a.wtlineage.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Non-inflamed Groups", cex.main=0.8,
        ylim=c(0,1))
dev.off()

pdf(here("boxplots","acrossGroups_pearson","fig4_NONinflamed_asv_supp.pdf"))
boxplot(corr_acrossGroups_pearson_asvCounts_withHuman[[2]][fig4a.wtlineage.supp.index],names = corr_acrossGroups_pearson_asvCounts_withHuman[[1]][fig4a.wtlineage.supp.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Non-inflamed Groups (SUPPFIG)", cex.main=0.8,
        ylim=c(0,1))
dev.off()

    #genus counts

pdf(here("boxplots","acrossGroups_pearson", "fig4_NONinflamed_genus.pdf"))
boxplot(corr_acrossGroups_pearson_GenusCounts_withHuman[[2]][fig4a.wtlineage.index],names = corr_acrossGroups_pearson_GenusCounts_withHuman[[1]][fig4a.wtlineage.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Non-inflamed Groups (Genus)", cex.main=0.8,
        ylim=c(0,1))
dev.off()

pdf(here("boxplots","acrossGroups_pearson","fig4_NONinflamed_genus_supp.pdf"))
boxplot(corr_acrossGroups_pearson_GenusCounts_withHuman[[2]][fig4a.wtlineage.supp.index],names = corr_acrossGroups_pearson_GenusCounts_withHuman[[1]][fig4a.wtlineage.supp.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Non-inflamed Groups (Genus,SUPPFIG)", cex.main=0.8,
        ylim=c(0,1))
dev.off()

  # phylum counts

pdf(here("boxplots","acrossGroups_pearson","fig4_NONinflamed_phylum.pdf"))
boxplot(corr_acrossGroups_pearson_PhylumCounts_withHuman[[2]][fig4a.wtlineage.index],names = corr_acrossGroups_pearson_PhylumCounts_withHuman[[1]][fig4a.wtlineage.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Non-inflamed Groups (Phylum)", cex.main=0.8,
        ylim=c(0,1))
dev.off()

pdf(here("boxplots","acrossGroups_pearson","fig4_NONinflamed_phylum_supp.pdf"))
boxplot(corr_acrossGroups_pearson_PhylumCounts_withHuman[[2]][fig4a.wtlineage.supp.index],names = corr_acrossGroups_pearson_PhylumCounts_withHuman[[1]][fig4a.wtlineage.supp.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Non-inflamed Groups (Phylum,SUPPFIG)", cex.main=0.8,
        ylim=c(0,1))
dev.off()

```

These boxplots include the cross-over groups in our SV transfer
comparison across groups.

```{r, message=FALSE, results='hide', fig.show='hide'}

#asv counts
pdf(here("boxplots","acrossGroups_pearson","fig4_crossover_asv.pdf"), width = 10)
boxplot(corr_acrossGroups_pearson_asvCounts_withHuman[[2]][fig4c.index],names = corr_acrossGroups_pearson_asvCounts_withHuman[[1]][fig4c.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Cross-over Group", cex.main=0.8,
        ylim=c(0,1))
dev.off()

pdf(here("boxplots","acrossGroups_pearson","fig4_crossover_supp_asv.pdf"))
boxplot(corr_acrossGroups_pearson_asvCounts_withHuman[[2]][fig4c.supp.index],names = corr_acrossGroups_pearson_asvCounts_withHuman[[1]][fig4c.supp.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Cross-over Group (SUPPFIG)", cex.main=0.8,
        ylim=c(0,1))
dev.off()

    #genus counts
pdf(here("boxplots","acrossGroups_pearson","fig4_crossover_genus.pdf"))
boxplot(corr_acrossGroups_pearson_GenusCounts_withHuman[[2]][fig4c.index],
        names = corr_acrossGroups_pearson_GenusCounts_withHuman[[1]][fig4c.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Cross-over Group (Genus)", cex.main=0.8,
        ylim=c(0,1))
dev.off()

pdf(here("boxplots","acrossGroups_pearson","fig4_crossover_supp_genus.pdf"))
boxplot(corr_acrossGroups_pearson_GenusCounts_withHuman[[2]][fig4c.supp.index],names = corr_acrossGroups_pearson_GenusCounts_withHuman[[1]][fig4c.supp.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Cross-over Group (Genus, SUPPFIG)", cex.main=0.8,
        ylim=c(0,1))
dev.off()

    #phylum counts 
pdf(here("boxplots","acrossGroups_pearson","fig4_crossover_phylum.pdf"))
boxplot(corr_acrossGroups_pearson_PhylumCounts_withHuman[[2]][fig4c.index],
        names = corr_acrossGroups_pearson_PhylumCounts_withHuman[[1]][fig4c.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Cross-over Group (Phylum)", cex.main=0.8,
        ylim=c(0,1))
dev.off()

pdf(here("boxplots","acrossGroups_pearson","fig4_crossover_supp_phylum.pdf"))
boxplot(corr_acrossGroups_pearson_PhylumCounts_withHuman[[2]][fig4c.supp.index],names = corr_acrossGroups_pearson_PhylumCounts_withHuman[[1]][fig4c.supp.index],  cex.axis=0.6,
        main="Correlation Coefficients Across Groups, Cross-over Group (Phylum, SUPPFIG)", cex.main=0.8,
        ylim=c(0,1))
dev.off()

```

#### ASV Transfer Efficiencies Across FMT Groups: Non-transferred ASVs

Here, we plot the abundance of the non-transferred ASVs as histograms.

```{r, message=FALSE, results='hide', fig.show='hide'}

dir.create(here("histograms_nontransferredASV","tablesWithTaxonomy"),recursive = T)

labels_NIMM_lineage = c("HM1input", "HM1->WT", "NIMM-g1input", "NIMM-g1->WT", "NIMM-g2input", "NIMM-g2->WT")
labels_IMM_lineage = c("HM1input", "HM1->KO", "IMM-g1input", "IMM-g1->KO","IMM-g2input", "IMM-g2->KO")


generateScatterPlots_samplePairsAcrossGroup_histogramOfNontransferringASVS(groupList=labels_serialpassage_newNames, 
                                                                      tableWithMeta=myASVandMetadata_newNames, 
                                                                         tableCountsOnly=file_asv_updatedName_t_samplesOnly_lognorm, resultsDirectory = here("histograms_nontransferredASV", "histogram_"))

#tables of non-transferred asvs with taxa name in each

generateTableWithTaxonomy_NontransferringASVS_samplePairsAcrossGroup(groupList=labels_serialpassage_newNames,
                                                                     taxonomyMap=asv_taxonomy_map,
                                                                     taxaColName="taxonomy",
                                                                     asvColName="OTUID",
                                                                     tableWithMeta=myASVandMetadata_newNames,
                                                                     tableCountsOnly=file_asv_updatedName_t_samplesOnly_lognorm,
                                                                     resultsDirectory=here("histograms_nontransferredASV","tablesWithTaxonomy", "table_"))



```

#### ASV Transfer Efficiencies Within FMT Groups at the Phylum level

The code below parses the taxonomy column to count the number of
different phylum present in this counts table. The phylum "NA" means
unclassified.

There are a total of 13 phyla in the ASV counts table. Of these 13
phyla, only four had one ASV present. For statistical testing purposes,
these phyla were excluded from the Pearson Correlation Coefficient test:
Arthropoda, Cyanobacteria, Desulfobacterota, and Vertebrata.
Campilobacterota and Patescibacteria were very sparse (present in 5 or
less samples each), and since this led to empty results in the boxplot,
we excluded these two phyla as well.

```{r, message=FALSE, results='hide', fig.show='hide'}

taxanames_all = file_asv_updatedName$taxonomy

taxanames_all_split = strsplit(taxanames_all, ";")

phylum_label = NULL

for(i in 1:length(taxanames_all_split)){
  phylum_label[i] = taxanames_all_split[[i]][2]
}

phylum_label_short = gsub("p__", "", phylum_label)
phylum_label_short = gsub(" ", "", phylum_label_short)

mapping_ASVandPhyla = data.frame("ASV" = file_asv_updatedName$OTUID, "PhylumLabels" = phylum_label_short)
table(mapping_ASVandPhyla$PhylumLabels)

mapping_ASVandPhyla$PhylumLabels[is.na(mapping_ASVandPhyla$PhylumLabels)] = "Unclassified"

#exclude the single ASV phylum
phlyum_groups = unique(mapping_ASVandPhyla$PhylumLabels)
singles = c("Arthropoda","Cyanobacteria","Desulfobacterota", "Vertebrata")
phlyum_groups_subset = phlyum_groups[! phlyum_groups %in% singles]

#rename the NA group in phylum list 
phlyum_groups_subset_2 = phlyum_groups_subset
phlyum_groups_subset_2[7] = "Unclassified"

phlyum_groups_subset_withoutSparsePhyla = phlyum_groups_subset_2[phlyum_groups_subset_2 != "Patescibacteria" & phlyum_groups_subset_2 != "Campilobacterota"]

phlyum_groups_subset_withoutSparsePhyla[7] = "Unclassified"

myGroup_serialPassage_miceOnly = c("IMM-g1->KO", "IMM-g2->KO", "NIMM-g1->WT", "NIMM-g2->WT")
myGroup_serialPassage_miceandHuman = c("IMM-g1->KO", "IMM-g2->KO", "NIMM-g1->WT", "NIMM-g2->WT", "HM1->KO", "HM1->WT")
sampleID_for_myGroup_serialPassage_miceOnly = metamapping_updatedName$SampleID[metamapping_updatedName$FMTGroupFMTsource..Recipientbackground %in% myGroup_serialPassage_miceOnly[1]]

mygroup_outfile_labels = gsub("->", "_to_", myGroup_serialPassage_miceandHuman)

## for selected FMT groups, generate correlations (samples within the same FMT group, stratified at the phylum taxa level) and boxplots of those correlations
for(i in 1:length(myGroup_serialPassage_miceandHuman)){
  
  myCorr_withinGroup_pearson_phlyum_perIRGroup_OUTPUT=getCorrelationCoefficient_withinGroup_phylumLevel_byGroup(groupList=phlyum_groups_subset_withoutSparsePhyla, tableWithMeta=myASVandMetadata_newNames, tableCountsOnly=file_asv_updatedName_t_samplesOnly_lognorm, corrTestMethod="pearson", sampleGroup = myGroup_serialPassage_miceandHuman[i], mappingMetaFile = mapping_ASVandPhyla,mappingMetaFile_taxaColName = "ASV", mappingMetaFile_phylumColName = "PhylumLabels", tableWithMeta_sampleColName = "SampleID" ,tableWithMeta_groupColName = "FMTGroupFMTsourcegtRecipientbackground")
  
  pdf(paste0(here("boxplots","withinGroups_pearson", "boxplot_phylum_"),mygroup_outfile_labels[i] , ".pdf"), width = 10)
  boxplot(myCorr_withinGroup_pearson_phlyum_perIRGroup_OUTPUT[[2]], names = phlyum_groups_subset_withoutSparsePhyla, main=paste0("Pearson Correlation Coefficient (R), Phylum Level ", myGroup_serialPassage_miceandHuman[i]), cex.axis=0.65, yaxt="n")
  axis(side=2, at=seq(0, 1, by=0.1))
  dev.off()
}

```

Next, we calculate t-test p-values to compare the correlations for each
phylum between WT and KO groups to determine if there are significant
differences between phylum for each phenotype.

At this time, we performed the t-test on the HM1toWT vs HM1toKO group.
Results are generated as a dataframe with unadjusted p-values for each
phylum. This dataframe is written out as a tab-delimited text file.

```{r, message=FALSE, results='hide', fig.show='hide'}

## ttest to compare wt and ko phylum groups

myCorr_withinGroup_pearson_phlyum_immg1toKO=getCorrelationCoefficient_withinGroup_phylumLevel_byGroup(groupList=phlyum_groups_subset_withoutSparsePhyla, tableWithMeta=myASVandMetadata_newNames, tableCountsOnly=file_asv_updatedName_t_samplesOnly_lognorm, corrTestMethod="pearson", sampleGroup = myGroup_serialPassage_miceandHuman[1], mappingMetaFile = mapping_ASVandPhyla,mappingMetaFile_taxaColName = "ASV", mappingMetaFile_phylumColName = "PhylumLabels", tableWithMeta_sampleColName = "SampleID" ,tableWithMeta_groupColName = "FMTGroupFMTsourcegtRecipientbackground")

myCorr_withinGroup_pearson_phlyum_nimmg1toWT=getCorrelationCoefficient_withinGroup_phylumLevel_byGroup(groupList=phlyum_groups_subset_withoutSparsePhyla, tableWithMeta=myASVandMetadata_newNames, tableCountsOnly=file_asv_updatedName_t_samplesOnly_lognorm, corrTestMethod="pearson", sampleGroup = myGroup_serialPassage_miceandHuman[3], mappingMetaFile = mapping_ASVandPhyla, mappingMetaFile_taxaColName = "ASV", mappingMetaFile_phylumColName = "PhylumLabels", tableWithMeta_sampleColName = "SampleID" ,tableWithMeta_groupColName = "FMTGroupFMTsourcegtRecipientbackground")

myCorr_withinGroup_pearson_phlyum_hm1toWT=getCorrelationCoefficient_withinGroup_phylumLevel_byGroup(groupList=phlyum_groups_subset_withoutSparsePhyla, tableWithMeta=myASVandMetadata_newNames, tableCountsOnly=file_asv_updatedName_t_samplesOnly_lognorm, corrTestMethod="pearson", sampleGroup = myGroup_serialPassage_miceandHuman[6], mappingMetaFile = mapping_ASVandPhyla,mappingMetaFile_taxaColName = "ASV", mappingMetaFile_phylumColName = "PhylumLabels", tableWithMeta_sampleColName = "SampleID" ,tableWithMeta_groupColName = "FMTGroupFMTsourcegtRecipientbackground")

myCorr_withinGroup_pearson_phlyum_hm1toKO=getCorrelationCoefficient_withinGroup_phylumLevel_byGroup(groupList=phlyum_groups_subset_withoutSparsePhyla, tableWithMeta=myASVandMetadata_newNames, tableCountsOnly=file_asv_updatedName_t_samplesOnly_lognorm, corrTestMethod="pearson", sampleGroup = myGroup_serialPassage_miceandHuman[5], mappingMetaFile = mapping_ASVandPhyla,mappingMetaFile_taxaColName = "ASV", mappingMetaFile_phylumColName = "PhylumLabels", tableWithMeta_sampleColName = "SampleID" ,tableWithMeta_groupColName = "FMTGroupFMTsourcegtRecipientbackground")


ttestpval_list = NULL
for(i in 1:length(phlyum_groups_subset_withoutSparsePhyla)){

  a = unlist(myCorr_withinGroup_pearson_phlyum_hm1toWT[[2]][i])
  b = unlist(myCorr_withinGroup_pearson_phlyum_hm1toKO[[2]][i]) 
  if(sum(is.na(a)) >=1 | sum(is.na(b)) >=1){print(paste0(phlyum_groups_subset_withoutSparsePhyla[i], " : NA"))} else {

  ttest_pval = t.test(a,b)$p.value
  resultstoprint = paste0(phlyum_groups_subset_withoutSparsePhyla[i],
                          ": ", ttest_pval)
  ttestpval_list[i] = ttest_pval
  
  }
}
   
mydf = data.frame("Phylum"=phlyum_groups_subset_withoutSparsePhyla, 
                    "Pvalue" = ttestpval_list)

write.table(mydf, here("boxplots","withinGroups_pearson","phylum_boxplot_ttest_hm1toWT_vs_hm1toKO.txt"), sep = "\t", quote = F, row.names = F)

```

The code below generates scatterplots of samples across all groups with
phylum-level counts data. This differs from the above figures, which
were based on ASV counts, but was sorted according to phyla taxonomic
classification.

```{r, message=FALSE, results='hide', fig.show='hide'}

dir.create(here("asvAbundance_scatterplots","acrossGroups_pearson_phylumCounts"), recursive = T)

corr_acrossGroups_pearson_PhylumCounts_withHuman = getCorrelationCoefficient_acrossGroup(groupList=labels_serialpassage_newNames, tableWithMeta=phylumCountsandMetadata, tableCountsOnly=phylumCounts_samplesOnly_df_lognorm, 
corrTestMethod="pearson", variableName = "FMTGroupFMTsourcegtRecipientbackground", sampleColumnName = "SampleID")

generateScatterplots_acrossGroup(groupList=labels_serialpassage_newNames, tableWithMeta=phylumCountsandMetadata,corrTestMethod = "pearson"  ,
                                 variableName = "FMTGroupFMTsourcegtRecipientbackground", sampleColumnName ="SampleID" ,tableCountsOnly=phylumCounts_samplesOnly_df_lognorm, resultsDirectory = here("asvAbundance_scatterplots","acrossGroups_pearson_phylumCounts","scatterplot_"))

```

#### Testing homogeneity of variances

Bartlett's test checks for equality of variances between two or more
groups.

Levene's test is the non-parametric version of variance equality
testing.

After testing the data for normality (Shapiro-Wilkes test), the data
presented with a normal distribution.

However, there were some outlier scores within some groups, so we also
performed the non-parametric Levene's test for a more robust assessment
of the histology scores.

```{r, message=FALSE, results='hide', fig.show='hide'}

histologyScores_hm1immg1immg2toKO = read.table(here("files", "histologyScores_hm1immg1immg2toKO.txt"), sep = "\t", header = T)

phenotype_groups = unique(histologyScores_hm1immg1immg2toKO$Group)
colnames(histologyScores_hm1immg1immg2toKO)
regions_list = c("Ileum", "Cecum","Proximal.Colon","Distal.Colon","Rectum")

bartlettResults_list = list()
for(i in 1:length(regions_list)){
  bartlettPvalues= calculateBartlettPvalue_histologyScoreData(histologyScores_hm1immg1immg2toKO,
                                                           regionColName = regions_list[i],      groupColName = "Group", phenotypeNames=phenotype_groups)
  
  bartlettResults_list[[i]]= bartlettPvalues
}

names(bartlettResults_list)=regions_list


barlettResult_totalColonScore = calculateBartlettPvalue_histologyScoreData(histologyScores_hm1immg1immg2toKO,
                                             regionColName = "Total.1", 
                                             groupColName = "Group", phenotypeNames=phenotype_groups)

levenesTest_totalColonScore=calculateLevenesTestPvalue_histologyScoreData(histologyScores_hm1immg1immg2toKO,regionColName = "Total.1", groupColName = "Group",phenotypeNames=phenotype_groups)


colnames(histologyScores_hm1immg1immg2toKO)


leveneResults_list = list()
for(i in 1:length(regions_list)){
  levenePvalues= calculateLevenesTestPvalue_histologyScoreData(histologyScores_hm1immg1immg2toKO,
                                                           regionColName = regions_list[i], groupColName = "Group",phenotypeNames=phenotype_groups)
  
  leveneResults_list[[i]]= levenePvalues
}

names(leveneResults_list)=regions_list

```

#### Cage Effect

We assess transfer inefficiencies for samples within the same groups per
cage. Since the transfer efficiency trends were consistent with the same
figure that was generated without cage data, we suggest that our
initially observed transfer efficiency values were not driven by cage
effect.

```{r, message=FALSE, results='hide', fig.show='hide'}
    
metadataNames= c("SampleID","UniversalCageNumber","Background", "FMTGroupFMTsourcegtRecipientbackground", 
               "Passge", "Sex", "Agewk", "SampleType")
fmtList_withinGroup = c("HM1->WT","NIMM-g1->WT", "NIMM-g2->WT", 
                        "HM1->KO", "IMM-g1->KO", "IMM-g2->KO")
withinGroups_perCage = getCorrelationCoefficient_withinGroup_perCage(tableWithMeta=myASVandMetadata_newNames, 
                                                                 corrTestMethod="pearson", 
                                                                 phenotypeGroup=fmtList_withinGroup, 
                                                                 tableWithMeta_sampleColName="SampleID",
                                                                 tableWithMeta_groupColName="FMTGroupFMTsourcegtRecipientbackground",
                                                                 tableWithMeta_cageColName="UniversalCageNumber",
                                                                metadataNames = metadataNames)


pdf(here("boxplots","Boxplots_WithinGroups_PerCage.pdf"))

par(mar=c(6, 4, 2, 2))
boxplot(withinGroups_perCage[[2]], names = withinGroups_perCage[[1]], las=2)
stripchart(withinGroups_perCage[[2]], method="jitter",add=T, pch=16, vertical = T)

dev.off()

```

#### Protein Assay: fLCN2

We compared log10 transformed and non-transformed protein assay data
with both t-test and Wilcoxon test.

```{r, message=FALSE, results='hide', fig.show='hide'}
# protein assay data: fLCN2

#histology scores, not in log space

fLCN2_immg1toko = c(228.75,178.26,489.264,396.486,260.886,4679.712,381.708,
                    507.51,3328.215,1100.715,300.915,43.543,11174.805,199.605,477.075
                    )
fLCN2_nimmg1toko = c(76.281,92.0298,6.3465,13.908,195.102,370.494,142.946,292.641,
                     177.647,9.036,221.677,237.329,47.194,910.155,77.11
                      )


#log10 + 1 
fLCN2_immg1toko_log10 = log10(fLCN2_immg1toko + 1)
fLCN2_nimmg1toko_log10 = log10(fLCN2_nimmg1toko + 1)

#histogram
par(mfrow=c(2,2))
hist(fLCN2_immg1toko, main="",xlim=c(0,10000))
hist(fLCN2_nimmg1toko, main="",xlim=c(0,10000))
hist(fLCN2_immg1toko_log10, main="",xlim=c(0,5))
hist(fLCN2_nimmg1toko_log10, main="",xlim=c(0,5))

# stat tests
ttest_pvals = t.test(fLCN2_immg1toko, fLCN2_nimmg1toko)$p.value
wilcoxon_pvals = wilcox.test(fLCN2_immg1toko, fLCN2_nimmg1toko)$p.value

ttest_pvals_log10input = t.test(fLCN2_immg1toko_log10, fLCN2_nimmg1toko_log10)$p.value
wilcoxon_pvals_log10input = wilcox.test(fLCN2_immg1toko_log10, fLCN2_nimmg1toko_log10)$p.value

#boxplots
pdf(here("boxplots","fLCN2_histologyScores.pdf"))

par(mfrow=c(1,2))
boxplot(list(fLCN2_immg1toko, fLCN2_nimmg1toko), names=c("IMMg1toKO", "NIMMg1toKO"),
        main=paste0("fLCN2 (Non-transformed Data)", "\nT-test Pval=", format(ttest_pvals, digits = 4),
                    ", Wilcoxon test Pval=", format(wilcoxon_pvals, digits = 4)),
        cex.main=0.85, col=c("red","royalblue"))
stripchart(list(fLCN2_immg1toko, fLCN2_nimmg1toko), 
           add=TRUE, vertical = T, pch=16)

boxplot(list(fLCN2_immg1toko_log10, fLCN2_nimmg1toko_log10), names=c("IMMg1toKO", "NIMMg1toKO"),
        main=paste0("fLCN2 (Log10 transformed Data)", "\nT-test Pval=", format(ttest_pvals_log10input, digits = 4),
                    ", Wilcoxon test Pval=", format(wilcoxon_pvals_log10input, digits = 4)),
        cex.main=0.85, col=c("red","royalblue"))
stripchart(list(fLCN2_immg1toko_log10, fLCN2_nimmg1toko_log10), 
           add=TRUE, vertical = T, pch=16)

dev.off()

```

#### Human to Mice FMT: Gnotobiotic Isolator

In this control experiment, nine mice (129.IL10KO recipient mice)
received human stool as input (HM2) in a fecal microbiome transfer
within a gnotobiotic transfer. We generated scatterplots to visualize
the transfer efficiency of samples from human to mice to see if we still
observe non-transferred ASVS that are bottlenecked in the human to mice
transfer; that is, we are ruling out environmental contamination as an
explanation of this phenomena.

As we observed in these scatterplots, there is still a microbial
bottleneck in the human to mice transfer.

```{r}
dir.create(here("asvAbundance_scatterplots","acrossGroups_pearson_gotobioticIsolator_data"), recursive = T)

asv_isolatedFMT = read.table(here("files","countsTable_asv_importToR_isolatorFMT.txt"), header = T, sep = "\t")
isolatedFMT_metadata_all = read.table(here("files","metadata_importToR_isolatorFMT.txt"), header = T, sep = "\t")

matchSampleIDFormat = gsub("-",".",isolatedFMT_metadata_all$SampleID)
isolatedFMT_metadata_all$SampleID = matchSampleIDFormat

asv_isolatedFMT_fmtGroups = unique(isolatedFMT_metadata_all$FMTGroup)

asv_isolatedFMT_t = t(asv_isolatedFMT)
asv_isolatedFMT_t_samplesOnly = asv_isolatedFMT_t[-(c(1,nrow(asv_isolatedFMT_t))),]
colnames(asv_isolatedFMT_t_samplesOnly) = asv_isolatedFMT_t[1,]


asv_isolatedFMT_t_samplesOnly_toMerge = as.data.frame(asv_isolatedFMT_t_samplesOnly)
asv_isolatedFMT_t_samplesOnly_toMerge$SampleID = rownames(asv_isolatedFMT_t_samplesOnly)

#merge counts and metadata files
isolatedFMT_ASVandMetadata_newNames = full_join(asv_isolatedFMT_t_samplesOnly_toMerge, isolatedFMT_metadata_all, by="SampleID")

##lognorm
asv_isolatedFMT_t_samplesOnly_df = as.data.frame(asv_isolatedFMT_t_samplesOnly)
asv_isolatedFMT_t_samplesOnly_df[] <- lapply(asv_isolatedFMT_t_samplesOnly_df, function(x) as.numeric(as.character(x)))

asv_isolatedFMT_t_samplesOnly_lognorm = lognorm_function(asv_isolatedFMT_t_samplesOnly_df)

# fmt groups
my_asv_isolatedFMT_fmtGroups = c("h3-4-5_input", "h3-4-5->KO")

# across group correlations
corr_acrossGroups_pearson_isolated_asvs = getCorrelationCoefficient_acrossGroup(groupList=my_asv_isolatedFMT_fmtGroups, tableWithMeta=isolatedFMT_ASVandMetadata_newNames, 
                                                                                tableCountsOnly=asv_isolatedFMT_t_samplesOnly_lognorm, 
                                                                                corrTestMethod="pearson",
                                                                                variableName = "FMTGroup", sampleColumnName = "SampleID")

#scatterplots
generateScatterplots_acrossGroup(groupList=my_asv_isolatedFMT_fmtGroups, tableWithMeta=isolatedFMT_ASVandMetadata_newNames,
                                 corrTestMethod = "pearson"  ,
                                 variableName = "FMTGroup", 
                                 sampleColumnName ="SampleID" ,tableCountsOnly=asv_isolatedFMT_t_samplesOnly_lognorm, 
                                 resultsDirectory = here("asvAbundance_scatterplots","acrossGroups_pearson_gotobioticIsolator_data", "scatterplot_"))


```


#### Figure 6: PCoA ordination and taxonomic relative abundance

In Figure 6 and 6S, to assess the variation and stability of the initial transfer with the HM1 cohort, we generated PCoA plots and taxonomic bar plots for replicate experiments within the following FMT treatment groups: HM1, HM2, and IMM-g1->KO using the Plotmicrobiome application. These figures were tested and validated by Jacqueline B. Young, with the respective Python scripts available on the Github repository under the "Testing" directory. 